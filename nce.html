<!DOCTYPE html>
<html spellcheck="false">
    <head>
        <title>Nandgame Computer Emulator</title>
        <meta charset="utf-8" />
        <style>

* {
    box-sizing: border-box;
    font-family: inherit;
    background-color: inherit;
    color: inherit;
}

html, body {
    position: absolute;
    inset: 0;
}

body {
    display: flex;
    flex-direction: row;
    margin: 0;
    font-family: Arial, Helvetica, sans-serif;
    background-color: #ffffff;
    color: #000000;
}

button {
    padding: 10px;
    font-size: inherit;
    background-color: #6c757d;
    color: white;
    border: none;
    border-radius: 5px;
}

button.blue {
    background-color: #0d6efd;
}

button.red {
    background-color: #dc3545;
}

code, pre {
    font-family: 'Courier New', Courier, monospace;
    font-size: inherit;
}

#left {
    flex: 1;
    display: flex;
    flex-direction: column;
}

#files-wrapper {
    min-width: 20ch;
    height: 100%;
    display: flex;
    flex-direction: column;
    border: 1px solid #dfdfdf;
    border-radius: 10px;
}

#files-header {
    padding: 10px;
    background-color: #f7f7f7;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
}

#files {
    flex: 1;
}

.file {
    padding: 10px;
    display: flex;
    flex-direction: row;
    align-items: center;
    font-family: 'Courier New', Courier, monospace;
}

.file.selected {
    background-color: #0d6efd;
    color: white;
}

#file-buttons {
    padding: 10px;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    gap: 10px;
}

#left h1 {
    margin: 0;
    padding: 13px;
    font-size: 1.5rem;
    font-weight: inherit;
    background-color: #343a40;
    color: white;
}

#editor-area {
    flex: 1;
    height: calc(100% - 1.5em - 30px);
    padding: 30px;
    padding-right: 15px;
    display: flex;
    flex-direction: row;
    gap: 30px;
}

#editor {
    flex: 1;
    max-height: 100%;
    justify-self: stretch;
    background: #1e1e1e;
    color: #ffffff;
    font-family: 'Courier New', Courier, monospace !important;
    font-size: 15px !important;
    line-height: 1 !important;
    overflow: auto;
}

.scrollbar::-webkit-scrollbar {
    width: 14px;
}

.scrollbar::-webkit-scrollbar-track {
    box-shadow: inset 0 0 2px #424242;
}

.scrollbar::-webkit-scrollbar-thumb {
    background-color: #383838;
}

@supports (scrollbar-color: #383838 #1e1e1e) {
    .scrollbar {
        scrollbar-color: #383838 #1e1e1e;
    }
}

@supports (scrollbar-color: #383838 #1e1e1e) and selector(::-webkit-scrollbar) {
    .scrollbar {
        scrollbar-color: initial;
    }
}

.cm-editor.cm-focused {
    outline: none;
}

.cm-editor span {
    background: inherit;
}

.cm-cursor {
    border-left-color: #ffffff !important;
}

.cm-content {
    background-color: transparent;
}

.cm-selectionBackground, .cm-content ::selection {
    background: #264f78 !important;
}

.cm-selectionMatch {
    background-color: #474747 !important;
}

.cm-gutters, .cm-gutter {
    background: #1e1e1e !important;
    color: #858585 !important;
    border: none !important;
}

.cm-activeLine {
    background: unset !important;
}

.cm-activeLineGutter {
    background-color: inherit !important;
    color: #c6c6c6 !important;
}

#right {
    flex: 1;
    display: flex;
    flex-direction: column;
}

#tabs {
    padding-top: 4px;
    display: flex;
    flex-direction: row;
    background-color: #343a40;
}

#tabs button {
    padding: 15px;
    background-color: #cccccc;
    color: #0d6efd;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
}

#tabs button.selected {
    background-color: #ffffff;
    color: #495057;
}

#assembler, #emulator, #help {
    flex: 1;
    height: calc(100% - 26px - 1.5rem);
    padding: 30px;
    padding-left: 15px;
}

#assembler, #emulator {
    flex-direction: column;
    gap: 30px;
}

#assembler {
    display: flex;
}

#assembler-top {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3ch;
}

#assembled {
    flex: 1;
    max-height: calc(100% - 1em - 46px);
    padding: 5px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 15px;
    background-color: #1e1e1e;
    overflow-y: auto;
    white-space: pre-wrap;
}

#emulator, #help {
    display: none;
    overflow-y: auto;
}

#emulator button {
    padding: 10px;
    background-color: #6c757d;
    color: white;
}

#top-buttons {
    display: flex;
    flex-direction: row;
    gap: 30px;
}

#top-buttons button {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 1ch;
}

#run svg {
    height: 1em;
    width: 0.75em;
}

#top-buttons #stop {
    display: none;
}

#stop svg {
    height: 1em;
    width: 1em;
}

#tick svg {
    height: 1em;
    width: 0.8125em;
}

input {
    appearance: textfield;
    padding: 5px;
    font-size: inherit;
    border: 1px solid #ced4da;
    border-radius: 5px;
}

input:invalid {
    color: red;
}

input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

input:focus {
    outline: none;
}

#clock-speed {
    width: 10ch;
}

table, tr, th, td {
    font-size: inherit;
    border: 1px solid black;
    border-collapse: collapse;
}

#tables {
    display: flex;
    flex-direction: row;
    gap: 30px;
}

#registers {
    font-family: 'Courier New', Courier, monospace;
}

th, td {
    padding: 5px;
    min-width: 1px;
    white-space: nowrap;
}

td input {
    border: none;
    padding: 0;
}

#registers input.hex {
    width: 4ch;
}

#registers input.dec {
    width: 6ch;
}

#registers input.bin {
    width: 16ch;
}

#tt-wrapper {
    display: none;
}

#help h1 {
    margin-top: 0;
}

        </style>
    </head>
    <body>
        <div id="left">
            <h1>Nandgame Computer Emulator</h1>
            <div id="editor-area">
                <div id="files-wrapper">
                    <div id="files-header">Files</div>
                    <div id="files" class="scrollbar"></div>
                    <div id="file-buttons">
                        <button id="new-file">New</button>
                        <button id="edit-file">Edit</button>
                        <button id="delete-file" class="red">Delete</button>
                    </div>
                </div>
                <div id="editor" class="scrollbar"></div>
            </div>
        </div>
        <div id="right">
            <div id="tabs">
                <button id="assembler-button" class="selected">Assembler</button>
                <button id="emulator-button">Emulator</button>
                <button id="help-button">Help</button>
            </div>
            <div id="assembler">
                <div id="assembler-top">
                    <button id="assemble" class="blue">Assemble</button>
                    <div id="loc"></div>
                </div>
                <div id="assembled" class="scrollbar"></div>
            </div>
            <div id="emulator">
                <div id="top-buttons">
                    <button id="load-code">Load Code</button>
                    <button id="run">
                        <svg viewBox="0 0 12 16">
                            <polygon points="0,0 12,8 0,16" stroke-width="0" fill="white" />
                        </svg>
                        Run
                    </button>
                    <button id="stop">
                        <svg viewBox="0 0 16 16">
                            <rect x="0" y="0" width="16" height="16" rx="2" ry="2" stroke-width="0" fill="white" />
                        </svg>
                        Stop
                    </button>
                    <button id="tick">
                        <svg viewBox="0 0 13 16">
                            <polygon points="0,0 12,8 0,16" stroke-width="0" fill="white" />
                            <rect x="12" y="2" width="1" height="12" stroke-width="0" fill="white" />
                        </svg>
                        Tick
                    </button>
                    <button id="reset">Reset</button>
                </div>
                <div>Clock speed: <input type="number" id="clock-speed" min="0" value="10" /> Hz</div>
                <div id="tables">
                    <table id="registers">
                        <tr>
                            <th>Name</th>
                            <th>Hex</th>
                            <th>Dec</th>
                            <th>Bin</th>
                        </tr>
                    </table>
                    <!-- <table id="memory">
                        <tr>
                            <td colspan="2">Page: <input type="number" id="page" min="0" max="32767" /></td>
                        </tr>
                        <tr>
                            <th>Address</th>
                            <th>Value</th>
                        </tr>
                    </table> -->
                </div>
                <div>Mode <span id="md">0</span><br><span id="tt-wrapper">Ticks until forced context switch: <span id="tt"></span></span><br><br><button id="sw">SW</button></div>
            </div>
            <div id="help">
                <h1>Help</h1>
                <p>This program implements the nandgame multitasking computer. It is a 16-bit, von Neumann architecture.</p>
                <p>There are 8 registers:</p>
                <ul>
                    <li><code>A</code>: address</li>
                    <li><code>D</code>: data</li>
                    <li><code>M</code>: mode (the segment register)</li>
                    <li><code>PC</code>: program counter</li>
                    <li><code>Ab</code>, <code>Db</code>, <code>Mb</code>, <code>PCb</code>: the backup registers</li>
                </ul>
                <p><code>*A</code> refers to the value in memory at address A.</p>
                <p>There are 2^18 addresses (0.5 MiB) of RAM.</p>
                <p>There are 3 types of instructions: ALU, data, and control.</p>
                <h2>ALU Instructions</h2>
                <p>The syntax is <code>destination = calculation ; jump</code>. Some parts can be omitted, so <code>destination = calculation</code>, <code>calculation ; jump</code>, or <code>jump</code> are all valid syntax.</p>
                <p>Valid destinations are: <code>A</code>, <code>D</code>, <code>*A</code>, or any combination of the 3.</p>
                <p>Calculations:</p>
                <ul>
                    <li><code>D + A</code> or <code>A + D</code></li>
                    <li><code>D - A</code> or <code>A - D</code></li>
                    <li><code>D & A</code> or <code>A & D</code> (bitwise AND)</li>
                    <li><code>D | A</code> or <code>A | D</code> (bitwise OR)</li>
                    <li><code>D ^ A</code> or <code>A ^ D</code> (bitwise XOR)</li>
                    <li><code>D + 1</code> or <code>A + 1</code></li>
                    <li><code>D - 1</code> or <code>A - 1</code></li>
                    <li><code>-D</code> or <code>-A</code></li>
                    <li><code>~D</code> or <code>~A</code> (bitwise negation)</li>
                    <li><code>1</code> or <code>0</code> or <code>-1</code></li>
                    <li><code>A</code> or <code>D</code></li>
                </ul>
                <p>In all calculations, <code>A</code> can be replaced with <code>*A</code>.</p>
                <p>Jump conditions apply when the calculation result satisfies some condition:</p>
                <ul>
                    <li><code>JMP</code>: always jump, regardless of the result</li>
                    <li><code>JEQ</code>: jump if the calculation is equal to 0</li>
                    <li><code>JNE</code>: jump if the calculation is not equal to 0</li>
                    <li><code>JLT</code>: jump if the calculation is less than 0 (the MSB (most significant bit/bit 15) is 1)</li>
                    <li><code>JLE</code>: jump if the calculation is less than or equal to 0</li>
                    <li><code>JGT</code>: jump if the calculation is greater than 0</li>
                    <li><code>JGE</code>: jump if the calculation is greater than or equal to 0</li>
                </ul>
                <h2>Data instructions</h2>
                <p>The syntax is <code>A = number</code>.&nbsp;&nbsp;&nbsp;<code>number</code> can optionally be prefixed with <code>0x</code> for hexadecimal, <code>0b</code> for binary, or <code>0o</code> for octal, but it must be positive (the MSB must be 0).</p>
                <h2>Control instructions</h2>
                <p>The syntax is <code>destination = register</code>.&nbsp;&nbsp;&nbsp;<code>; SW</code> can also be suffixed to switch the mode (there is more about that below). Again, just plain <code>SW</code> is also valid syntax.</p>
                <p>The input register can be any of the 8 registers, <code>A</code>, <code>D</code>, <code>M</code>, <code>PC</code>, <code>Ab</code>, <code>Db</code>, <code>Mb</code>, or <code>PCb</code>.</p>
                <p>The destination can be a combination of these registers, however, they must either all be backup or none be backup. So, <code>A = Ab</code>, <code>A, D = Ab</code>, or <code>Db, Mb = PCb</code> are all valid, but not <code>D, Mb = PCb</code>.</p>
                <h2>Multitasking</h2>
                <p>This is a multitasking computer. There are 2 modes, 0 (kernel), and 1 (user). Kernel mode can write to all registers, user mode can only write to <code>A</code>, <code>D</code>, and <code>PC</code>. When kernel mode uses <code>SW</code>, the mode is switched to 1 and a timer is started (this differs from the actual nandgame multitasking computer, where the timer is always going). After 256 clock cycles, the computer will be forcibly switched back to user mode. However, user mode can also switch itself back by using <code>SW</code>.</p>
                <p>When switching from kernel to user mode, the backup and normal registers are all swapped. When switching from user to kernel mode, <code>A</code> and <code>Ab</code> are swapped, <code>D</code> is set to 1 if it was triggered by the timer, or 2 if it was triggered by code. <code>M</code> is set to 0, and <code>PC</code> and <code>PCb</code> are swapped.</p>
                <p>There is a virtual memory system, controlled by the <code>M</code> register. It applies for both <code>PC</code> and <code>A</code>. They are turned from 16-bit into 18-bit addresses via the following algorithm.</p>
                <p>For <code>PC</code>: If the MSB is 0, take bits 0-2 of <code>M</code> and concatenate them to the other 15 bits of <code>PC</code>. If it is 1, take bits 4-6 of <code>M</code> instead.</p>
                <p>For <code>A</code>: If the MSB is 0, take bits 8-10 of <code>M</code> and concatenate them to the other 15 bits of <code>A</code>. If it is 1, take bits 12-14 of <code>M</code> instead.</p>
                <h2>Assembler Features</h2>
                <p>Python-style comments can be done with syntax such as <code># comment</code>.</p>
                <p>Constants can be defined like <code>define LOCALS 2</code> (<code>DEFINE</code> also works).</p>
                <p>Labels can be defined like <code>labelname:</code>. The instruction after the label's address will be stored in a constant named <code>labelname</code>. They can also be defined using more verbose syntax like <code>label labelname</code> (<code>LABEL</code> also works).</p>
                <p>Because it is a von Neumann architecture, it is often useful to insert in data. This is done through syntax like <code>data 0xc</code>. The same number representation formats used for data instructions can all be used here.</p>
                <p>It is also often useful to change the addresses at which instructions are inserted at. This is done through <code>loadat 0x7c00</code>. Again, all the number representation formats can be used.</p>
                <p>Other files can be included with <code>include filename</code> (<code>INCLUDE filename</code> also works).</p>
                <p>Finally, macros can be done like this:</p>
                <pre>macro macroname arg1 arg2<br># code that uses the arguments<br>endmacro</pre>
                <p>They are invoked like <code>macroname argvalue1 argvalue2</code>. The number of arguments in the definition and in the call must match.</p>
            </div>
        </div>
        <script>'use strict';let currentlyLoading;function printError(e,c='red'){let x=String(e instanceof Error?e.stack:e);if(!x.includes('Error')){x=String(e)+'\n'+x.trim().split('\n').map(x=>'    at '+x).join('\n').replaceAll('@',' at ').replaceAll('at  at', 'at');}if(currentlyLoading){x=`(in ${currentlyLoading}): `+x;}if(!(document.readyState==='complete')){alert(x);return;}document.querySelectorAll('body > *').forEach(x=>x.remove());let t=document.createElement('pre');t.style.color=c;t.style.paddingLeft='15px';t.style.fontFamily='\'Courier New\',Courier,monospace';t.style.fontSize='14px';t.style.overflowX='wrap';t.textContent=x.replaceAll(/file:\/\/\/media\/fuse\/drivefs-[0-9a-f]+\/root\/code\//g,'');document.body.style.padding='0';document.body.style.paddingBottom='15px !important';document.body.appendChild(t);let l=setInterval(() => {}, 0);for(let j=1;j<=l;j++){clearInterval(j);}window.onkeydown=()=>{};}window.addEventListener('error',e=>{printError(e.error);return true;});window.addEventListener('unhandledrejection',e=>{e.preventDefault();printError(e.reason);});</script>
        <script type="module">

import {EditorView, basicSetup} from 'https://esm.sh/codemirror@6.0.1';
import {keymap} from 'https://esm.sh/@codemirror/view@^6.0.0';
import {EditorState, EditorSelection, SelectionRange} from 'https://esm.sh/@codemirror/state@^6.0.0';
import {indentWithTab} from 'https://esm.sh/@codemirror/commands@^6.0.0';
import {StreamLanguage, HighlightStyle, syntaxHighlighting, indentUnit, StringStream} from 'https://esm.sh/@codemirror/language@^6.0.0';
import {tags as t} from 'https://esm.sh/@lezer/highlight@1.2.1';


const LABEL_REGEX = /^(\*?)[a-zA-Z_.$][a-zA-Z0-9_.$]*/;
const NUMBER_REGEX = /^-?(0b[01]+|0o[0-7]+|0x[0-9A-Fa-f]+|\d+)/;
const REGISTERS = ['A', 'D', '*A', 'PC', 'M', 'Ab', 'Db', 'Mb', 'PCb'];
const JUMPS = ['JMP', 'JEQ', 'JNE', 'JLT', 'JLE', 'JGT', 'JGE', 'SW'];
const KEYWORDS = ['label', 'define', 'macro', 'endmacro', 'data', 'loadat', 'include', 'DEFINE', 'MACRO', 'ENDMACRO', 'LABEL', 'DATA', 'LOADAT', 'INCLUDE'];


function highlighter(stream) {
    let match;
    if (stream.eatSpace()) {
        return;
    } else if (match = stream.match(LABEL_REGEX)) {
        let name = match[0];
        if (REGISTERS.includes(name)) {
            return 'keyword';
        } else if (JUMPS.includes(name)) {
            return 'controlKeyword';
        } else if (KEYWORDS.includes(name)) {
            return 'definitionKeyword';
        } else {
            return 'variableName';
        }
    } else if (stream.match(/#.*/)) {
        return 'comment';
    } else {
        stream.match(NUMBER_REGEX);
        stream.next();
    }
}

let files = Object.create(null);
let currentFile;
if (localStorage.nceFiles !== undefined) {
    for (let [name, data] of Object.entries(JSON.parse(localStorage.nceFiles))) {
        files[name] = data;
    }
    if (localStorage.nceLastFile !== undefined) {
        currentFile = localStorage.nceLastFile;
    } else {
        currentFile = Object.keys(files)[0];
    }
} else {
    files.main = localStorage.nceCode ?? 'A = 0x7FFF\n*A, D = D + 1\nA = 0\nD = ~D ; JMP';
    currentFile = 'main';
    localStorage.nceLastFile = 'main';
}

let editor = new EditorView({
    doc: files[currentFile],
    parent: document.getElementById('editor'),
    extensions: [
        basicSetup,
        indentUnit.of('    '),
        keymap.of(indentWithTab),
        StreamLanguage.define({token: highlighter}),
        syntaxHighlighting(HighlightStyle.define([
            {tag: t.keyword, color: '#4ec9b0'},
            {tag: t.controlKeyword, color: '#d4d4a4', fontWeight: 'bold'},
            {tag: t.variableName, color: '#9cdcfe', fontWeight: 'bold'},
            {tag: t.comment, color: '#6a9955', fontStyle: 'oblique'},
            {tag: t.definitionKeyword, color: '#c586c0', fontWeight: 'bold'},
        ])),
        EditorView.updateListener.of((update) => {
            if (update.docChanged) {
                files[currentFile] = update.state.doc.toString();
            }
            if (update.selectionSet) {
                let selection = update.state.selection;
                selection.ranges.forEach(range => {
                    let lineEnd = update.state.doc.lineAt(range.head).to;
                    if (range.anchor > lineEnd) {
                        update.view.dispatch({selection: EditorSelection.create([new SelectionRange({anchor: lineEnd, head: lineEnd})])});
                    }
                });
            }
        }),
    ],
});

setInterval(() => {
    localStorage.nceFiles = JSON.stringify(files);
}, 2000);

let fileElts = Object.create(null);

function changeFile(name) {
    fileElts[currentFile].className = 'file';
    fileElts[name].className = 'file selected';
    currentFile = name;
    localStorage.nceLastFile = name;
    editor.dispatch({
        changes: {
            from: 0,
            to: editor.state.doc.length,
            insert: files[currentFile],
        },
    });
}

let filesElt = document.getElementById('files');

function addFileElt(name) {
    let elt = document.createElement('div');
    if (currentFile === name) {
        elt.className = 'file selected';
    } else {
        elt.className = 'file';
    }
    elt.textContent = name;
    elt.addEventListener('click', () => changeFile(name));
    filesElt.appendChild(elt);
    fileElts[name] = elt;
}

for (let name in files) {
    addFileElt(name);
}

document.getElementById('new-file').addEventListener('click', () => {
    let name = prompt('Enter name for new file:');
    fileElts[currentFile].className = 'file';
    files[name] = '';
    currentFile = name;
    addFileElt(name);
    changeFile(name);
});

document.getElementById('edit-file').addEventListener('click', () => {
    let name = prompt(`Enter new name for '${currentFile}':`);
    files[name] = files[currentFile];
    delete files[currentFile];
    fileElts[name] = fileElts[currentFile];
    fileElts[name].textContent = name;
    delete fileElts[currentFile];
    currentFile = name;
});

document.getElementById('delete-file').addEventListener('click', () => {
    if (Object.keys(files).length === 1) {
        alert('Cannot delete file when only 1 file is present');
    } else if (confirm(`Are you sure you want to delete '${currentFile}'?`)) {
        delete files[currentFile];
        fileElts[currentFile].remove();
        delete fileElts[currentFile];
        currentFile = Object.keys(files)[0];
        changeFile(currentFile);
    }
});


let assemblerTab = document.getElementById('assembler');
let emulatorTab = document.getElementById('emulator');
let helpTab = document.getElementById('help');

let assemblerButton = document.getElementById('assembler-button');
let emulatorButton = document.getElementById('emulator-button');
let helpButton = document.getElementById('help-button');

assemblerButton.addEventListener('click', () => {
    assemblerTab.style.display = 'flex';
    emulatorTab.style.display = 'none';
    helpTab.style.display = 'none';
    assemblerButton.className = 'selected';
    emulatorButton.className = '';
    helpButton.className = '';
});

emulatorButton.addEventListener('click', () => {
    assemblerTab.style.display = 'none';
    emulatorTab.style.display = 'flex';
    helpTab.style.display = 'none';
    assemblerButton.className = '';
    emulatorButton.className = 'selected';
    helpButton.className = '';
});

helpButton.addEventListener('click', () => {
    assemblerTab.style.display = 'none';
    emulatorTab.style.display = 'none';
    helpTab.style.display = 'block';
    assemblerButton.className = '';
    emulatorButton.className = '';
    helpButton.className = 'selected';
});


function error(msg, token) {
    for (let {line, col, file, loc, raw, length} of token.stack) {
        let src = file + ':' + line + ':' + col;
        if (loc) {
            msg += `\n    at ${loc} (${src})`;
        } else {
            msg += `\n    at ${src}`;
        }
        msg += '\n        ' + raw;
        msg += '\n        ' + ' '.repeat(col) + '^'.repeat(length) + ' (here)';
    }
    throw new SyntaxError(msg);
}

function tokenize(filename) {
    let match;
    let code = files[filename];
    let lines = code.split('\n');
    let out = [];
    for (let lineno = 0; lineno < lines.length; lineno++) {
        let line = lines[lineno];
        let tokens = [];
        for (let i = 0; i < line.length; i++) {
            let char = line[i];
            let stack = [{
                line: lineno + 1,
                col: i,
                file: filename,
                raw: line,
            }];
            if (char === ' ' || char === '\t') {
                continue;
            } else if (line.slice(i).startsWith('include ')) {
                let file = line.slice(i + 'include '.length);
                out.push(...tokenize(file));
                break;
            } else if (char === '#') {
                break;
            } else if (match = line.slice(i).match(NUMBER_REGEX)) {
                stack[0].length = match[0].length;
                i += match[0].length - 1;
                tokens.push({
                    type: 'number',
                    value: parseInt(match[0]),
                    stack,
                });
            } else if (match = line.slice(i).match(LABEL_REGEX)) {
                stack[0].length = match[0].length;
                i += match[0].length - 1;
                let name = match[0];
                let type;
                if (REGISTERS.includes(name)) {
                    type = 'register';
                } else if (JUMPS.includes(name)) {
                    type = 'jump';
                } else if (KEYWORDS.includes(name)) {
                    type = 'keyword';
                    name = name.toLowerCase();
                } else {
                    type = 'variable';
                }
                tokens.push({
                    type,
                    value: name,
                    stack,
                });
            } else if (':,;=+-&|^~'.includes(char)) {
                stack[0].length = 1;
                tokens.push({
                    type: char,
                    value: char,
                    stack,
                });
            } else {
                throw new SyntaxError(`Invalid syntax on line ${lineno + 1}: '${line.slice(i)}'`);
            }
        }
        if (tokens.length > 0) {
            out.push(tokens);
        }
    }
    return out;
}

function preprocess(tokens) {
    let out = [];
    let inMacro = false;
    let macroToken;
    let macroArgs;
    let macroCode = [];
    let ids = Object.create(null);
    let address = 0;
    let lineCount = 0;
    for (let i = 0; i < tokens.length; i++) {
        let line = tokens[i];
        let lines = [line];
        if (line.length === 0) {
            continue;
        } else if (line[0].type === 'keyword' && line[0].value !== 'loadat' && line[0].value !== 'data') {
            if (line[0].value === 'define') {
                let name = line[1];
                if (!name) {
                    error(`Expected 1 or more tokens after 'define'`, line[0]);
                } else if (name.value in ids) {
                    error(`Redeclaration of '${name.value}'`, line[0]);
                } else {
                    let data = line.slice(2);
                    for (let token of data) {
                        token.stack[0].loc = `define '${name.value}'`;
                    }
                    ids[name.value] = {
                        type: 'define',
                        value: data,
                    };
                }
            } else if (line[0].value === 'macro') {
                if (inMacro) {
                    error(`Nested macros are not allowed`, line[0]);
                }
                let name = line[1];
                if (!name) {
                    error(`Expected 1 or more tokens after 'macro'`, line[0]);
                } else if (name.value in ids) {
                    error(`Redeclaration of '${name.value}'`, line[0]);
                } else {
                    inMacro = true;
                    macroToken = line[1];
                    macroArgs = line.slice(2).map(arg => {
                        if (arg.type !== 'variable') {
                            error(`Macro arguments must be variables`, arg);
                        }
                        return arg.value;
                    });
                }
            } else if (line[0].value === 'endmacro') {
                if (!inMacro) {
                    error(`No macro to end`, line[0]);
                }
                if (line.length !== 1) {
                    error(`Expected no tokens after 'endmacro'`, line[0]);
                }
                inMacro = false;
                ids[macroToken.value] = {
                    type: 'macro',
                    value: macroCode,
                    args: macroArgs,
                };
            } else if (line[0].value === 'label') {
                if (line.length !== 2) {
                    error(`Expected 1 token after 'label'`, line[0]);
                } else if (name.type !== 'variable') {
                    error(`Expected variable after 'label'`, name);
                }
                ids[line[1].value] = {
                    type: 'label',
                    value: {
                        type: 'number',
                        value: address,
                        stack: line[1].stack,
                    },
                };
            }
            continue;
        } else if (line[0].type === 'variable') {
            if (line.length === 2 && line[1].type === ':') {
                if (line[0].value in ids) {
                    error(`Redefinition of '${line[0].value}'`, line[0]);
                }
                line[0].stack[0].loc = 'label';
                ids[line[0].value] = {
                    type: 'label',
                    value: {
                        type: 'number',
                        value: address,
                        stack: line[0].stack,
                    },
                };
                continue;
            } else if (line[0].value in ids && ids[line[0].value].type === 'macro') {
                let value = ids[line[0].value];
                let argValues = line.slice(1);
                if (argValues.length !== value.args.length) {
                    error(`Expected ${value.args.length} arguments but got ${argValues.length} arguments`, line[0]);
                }
                let args = Object.create(null);
                for (let i = 0; i < value.args.length; i++) {
                    args[value.args[i]] = argValues[i];
                }
                let newStack = structuredClone(line[0].stack);
                lines = [];
                for (let line of value.value) {
                    let outLine = [];
                    for (let token of line) {
                        if (token.type === 'variable' && token.value in args) {
                            let arg = args[token.value];
                            arg = structuredClone(arg);
                            arg.stack.push(...structuredClone(token.stack));
                            outLine.push(arg);
                        } else {
                            token = structuredClone(token);
                            token.stack.unshift(...newStack);
                            outLine.push(token);
                        }
                    }
                    lines.push(outLine);
                }
                lineCount++;
            }
        } else if (!inMacro) {
            if (line[0].type === 'keyword' && line[0].value === 'loadat') {
                if (line.length === 2 && line[1].type === 'number') {
                    address = line[1].value - 1;
                }
            } else {
                lineCount++;
            }
        }
        if (inMacro) {
            macroCode.push(...lines);
        } else {
            for (let line of lines) {
                let outLine = [];
                for (let token of line) {
                    if (token.type === 'variable') {
                        if (!(token.value in ids)) {
                            error(`${token.value} is not defined`, token);
                        }
                        let {type, value} = ids[token.value];
                        if (type === 'label') {
                            value = [value];
                        }
                        if (type === 'macro') {
                            error(`Macro invocations must be at the start of a line`, token);
                        }
                        let newStack = structuredClone(token.stack);
                        outLine.push(...value.map(x => {
                            x = structuredClone(x);
                            x.stack.unshift(...newStack);
                            return x;
                        }));
                    } else {
                        outLine.push(token);
                    }
                }
                if (outLine.length > 0) {
                    out.push(outLine);
                    address++;
                }
            }
        }
    }
    if (inMacro) {
        error(`Macro '${macroToken.value}' was never ended`, macroToken);
    }
    return [out, lineCount];
}

const ALU_INSTRUCTIONS = {
    'D & A': 0b00000,
    'A & D': 0b00001,
    'D | A': 0b00100,
    'A | D': 0b00101,
    'D ^ A': 0b01000,
    'A ^ D': 0b01001,
    '~ D': 0b01100,
    '~ A': 0b01101,
    'D + A': 0b10000,
    'A + D': 0b10001,
    'D - A': 0b11001,
    'A - D': 0b11000,
    'D + 1': 0b10100,
    'A + 1': 0b10101,
    'D - 1': 0b11100,
    'A - 1': 0b11101,
    'D': 0b00111,
    'A': 0b00110,
    '0': 0b00010,
    '1': 0b10110,
    '-1': 0b11110,
};

function _assemble(lines) {
    let array = new Uint16Array(262144);
    let instructionCount = 0;
    let address = 0;
    for (let line of lines) {
        if (line.length === 3 && line[0].type === 'register' && line[0].value === 'A' && line[1].type === '=' && line[2].type === 'number') {
            let value = line[2].value;
            if (value < 0 || value > 32767) {
                error(`The A register cannot be set to ${line[2].value}`, line[2]);
            }
            array[address] = line[2].value;
            instructionCount++;
            address++;
            continue;
        } else if (line.length === 2 && line[0].type === 'keyword' && line[0].value === 'data' && line[1].type === 'number') {
            array[address] = line[1].value;
            instructionCount++;
            address++;
            continue;
        } else if (line.length === 2 && line[0].type === 'keyword' && line[0].value === 'loadat' && line[1].type === 'number') {
            address = line[1].value;
            continue;
        }
        instructionCount++;
        let expression = [];
        let assignedTo = null;
        let jump = null;
        let equalsFound = false;
        let semicolonFound = false;
        let semicolonToken;
        for (let token of line) {
            if (token.type === '=') {
                if (equalsFound) {
                    error(`More than 1 equal sign in the same line`, token);
                }
                equalsFound = true;
                assignedTo = expression;
                expression = [];
            } else if (token.type === ';') {
                if (semicolonFound) {
                    error(`More than 1 equal sign in the same line`, token);
                }
                semicolonFound = true;
                semicolonToken = token;
                jump = [];
            } else if (semicolonFound) {
                jump.push(token);
            } else {
                expression.push(token);
            }
        }
        if (assignedTo === null && jump === null && expression.every(x => x.type === 'jump')) {
            jump = expression;
            expression = null;
        }
        let jumpToken;
        if (jump) {
            if (jump.length === 0) {
                error(`No jump conditions`, semicolonToken);
            } else if (jump.length !== 1) {
                error(`More than 1 jump condition`, jump[1]);
            }
            jump = jump[0];
            if (jump.type !== 'jump') {
                error(`Invalid jump condition`, jump);
            }
            jumpToken = jump;
            jump = jump.value;
        }
        let out = 1 << 15;
        if (expression && expression.length === 1 && expression[0].type === 'register' && expression[0].value !== '*A' && !(jump && jump !== 'SW')) {
            out |= 1 << 14;
            if (jump) {
                out |= 1 << 13;
            }
            let reg = expression[0].value;
            if (reg.endsWith('b')) {
                reg = reg.slice(0, -1);
                out |= 1 << 6;
            }
            if (reg === 'D' || reg === 'PC') {
                out |= 1 << 7;
            }
            if (reg === 'M' || reg === 'PC') {
                out |= 1 << 8;
            }
            if (assignedTo) {
                let regs = [];
                for (let token of assignedTo) {
                    if (token.type === 'register') {
                        if (token.value === '*A') {
                            out |= 1 << 3;
                        } else {
                            regs.push(token.value);
                        }
                    } else if (token.type === ',') {
                        continue;
                    } else {
                        error(`Expected register or comma`, token);
                    }
                }
                if (regs.some(x => x.endsWith('b'))) {
                    if (!regs.every(x => x.endsWith('b'))) {
                        error(`Cannot assign to backup and non-backup registers simultaneously`, regs[0]);
                    }
                    regs = regs.map(x => x.slice(0, -1));
                    out |= 1;
                }
                for (let reg of regs) {
                    if (reg === 'A') {
                        out |= 1 << 5;
                    } else if (reg === 'D') {
                        out |= 1 << 4;
                    } else if (reg === 'M') {
                        out |= 1 << 2;
                    } else if (reg === 'PC') {
                        out |= 1 << 1;
                    }
                }
            }
        } else if (!expression && !assignedTo && jump.type === 'SW') {
            out |= 3 << 13;
        } else {
            let key;
            if (expression && expression.length > 0) {
                let aluStr = expression.map(x => x.value).join(' ');
                key = aluStr;
                if (key.includes('*A')) {
                    key = key.replace('*A', 'A');
                }
                if (!(key in ALU_INSTRUCTIONS)) {
                    error(`Invalid ALU instruction`, expression[0]);
                }
            } else {
                key = '0';
            }
            out |= ALU_INSTRUCTIONS[key] << 6;
            if (assignedTo) {
                for (let token of assignedTo) {
                    if (token.type === 'register') {
                        if (token.value === 'A') {
                            out |= 1 << 5;
                        } else if (token.value === 'D') {
                            out |= 1 << 4;
                        } else if (token.value === '*A') {
                            out |= 1 << 3;
                        } else {
                            error(`Cannot assign to ${token.value} in ALU instruction`, token);
                        }
                    } else if (token.type === ',') {
                        continue;
                    } else {
                        error(`Expected register or comma`, token);
                    }
                }
            }
            if (jump) {
                if (jump === 'JMP' || jump === 'JNE' || jump === 'JLT' || jump === 'JLE') {
                    out |= 1 << 2;
                }
                if (jump === 'JMP' || jump === 'JEQ' || jump === 'JLE' || jump === 'JGE') {
                    out |= 1 << 1;
                }
                if (jump === 'JMP' || jump === 'JNE' || jump === 'JGT' || jump === 'JGE') {
                    out |= 1;
                }
                if (jump === 'SW') {
                    error(`Invalid jump condition for ALU instruction`, jumpToken);
                }
            }
        }
        array[address] = out;
        address++;
    }
    return [array, instructionCount];
}

let assembled = null;
let assembledElt = document.getElementById('assembled');
let locElt = document.getElementById('loc');

let rem = parseFloat(getComputedStyle(document.documentElement).fontSize);

function assemble(set = false) {
    try {
        let instructionCount;
        let lineCount;
        let code = editor.state.doc.toString();
        code = tokenize(currentFile);
        [code, lineCount] = preprocess(code);
        [code, instructionCount] = _assemble(code);
        if (set) {
            let data = Array.from(code).map(x => x.toString(16).padStart(4, '0'));
            assembledElt.textContent = '';
            let maxWidth = assembledElt.getBoundingClientRect().width / rem / 0.6;
            let perLine = 2**Math.floor(Math.log2(Math.floor(maxWidth / 5) - 3));
            data = Array.from(Array.from({length: Math.ceil(data.length / perLine)}).map((_, i) => (i * perLine).toString(16).padStart(5, '0') + ': ' + data.slice(perLine * i, perLine * (i + 1)).join(' ')));
            assembledElt.textContent = data.join('\n');
            assembledElt.style.color = 'white';
            locElt.textContent = `${instructionCount} instructions, ${lineCount} lines`;
        }
        assembled = code;
        return code;
    } catch (error) {
        if (error instanceof SyntaxError) {
            assembled = null;
            if (set) {
                assembledElt.textContent = 'Error: ' + error.message;
                assembledElt.style.color = '#ff6666';
                locElt.textContent = '';
            }
        } else {
            throw error;
        }
    }
}

assemble();

document.getElementById('assemble').addEventListener('click', () => assemble(true));


let registers = new Uint16Array(8);
let memory = new Uint16Array(262144);
let md = 0;
let tt = 0;

function reset() {
    registers.fill(0);
    memory.fill(0);
    if (assembled !== null) {
        memory.set(assembled);
    }
    for (let i = 0; i < 8; i++) {
        updateRegisterDisplay(i);
    }
    updateStarADisplay();
    updateModeDisplay();
    md = 0;
    tt = 0;
}

document.getElementById('reset').addEventListener('click', () => {
    if (confirm('Are you sure you want to reset?')) {
        reset();
    }
});

const REGISTER_INPUT_TYPES = [
    {class: 'hex', type: 'text', pattern: '[0-9A-Fa-f]{1,4}', prefix: '0x'},
    {class: 'dec', type: 'number', pattern: '', prefix: ''},
    {class: 'bin', type: 'text', pattern: '[0-9]{1,16}', prefix: '0b'},
];

let registerInputs = [];
let starAInputs;

function updateRegisterDisplay(i) {
    let value = registers[i];
    if (i === 2) {
        i = 3;
    } else if (i === 3) {
        i = 2;
    }
    let {hex, dec, bin} = registerInputs[i];
    hex.value = value.toString(16).padStart(4, '0');
    dec.value = value.toString();
    bin.value = value.toString(2).padStart(16, '0');
    if (i === 0) {
        updateStarADisplay();
    }
}

function updateStarADisplay() {
    let value = memory[registers[0]];
    let {hex, dec, bin} = starAInputs;
    hex.value = value.toString(16).padStart(4, '0');
    dec.value = value.toString();
    bin.value = value.toString(2).padStart(16, '0');
}

let mdElt = document.getElementById('md');
let ttWrapperElt = document.getElementById('tt-wrapper');
let ttElt = document.getElementById('tt');

function updateModeDisplay() {
    mdElt.textContent = md;
    if (md === 1) {
        ttWrapperElt.style.display = 'inline';
        ttElt.textContent = tt;
    } else {
        ttWrapperElt.style.display = 'none';
    }
}

document.getElementById('sw').addEventListener('click', () => {
    md = md === 0 ? 1 : 0;
    if (md === 1) {
        tt = 256;
    }
    updateModeDisplay();
});

let registerTable = document.getElementById('registers');

for (let i = 0; i < REGISTERS.length; i++) {
    let row = document.createElement('tr');
    let name = document.createElement('td');
    name.textContent = REGISTERS[i];
    row.appendChild(name);
    let inputs = {};
    for (let spec of REGISTER_INPUT_TYPES) {
        let td = document.createElement('td');
        let input = document.createElement('input');
        input.className = spec.class;
        input.type = spec.type;
        input.pattern = spec.pattern;
        let updateNumber = i < 2 ? i : i - 1;
        input.addEventListener('change', () => {
            if (input.checkValidity()) {
                let value = parseInt(spec.prefix + input.value);
                if (i === 2) {
                    memory[((registers[0] & 32768) ? (((registers[2] >> 12) & 7) << 15) : (((registers[2] >> 8) & 7) << 15)) | (registers[0] & 32767)] = value;
                    updateStarADisplay();
                } else {
                    if (i === 3) {
                        registers[2] = value;
                    } else if (i === 2) {
                        registers[3] = value;
                    } else {
                        registers[i] = value;
                    }
                    updateRegisterDisplay(updateNumber);
                }
            }
        });
        td.appendChild(input);
        row.appendChild(td);
        inputs[spec.class] = input;
    }
    if (i === 2) {
        starAInputs = inputs;
    } else {
        registerInputs.push(inputs);
    }
    registerTable.appendChild(row);
}

reset();


document.getElementById('load-code').addEventListener('click', () => {
    if (confirm('Are you sure you want to load the code? This will reset the computer.')) {
        assemble();
        reset();
    }
});

function tick(display = true) {
    let i = memory[((registers[3] & 32768) ? (((registers[2] >> 4) & 7) << 15) : ((registers[2] & 7) << 15)) | (registers[3] & 32767)];
    let j = false;
    if (i & 32768) {
        if (i & 16384) {
            let x = registers[((i & 64) >> 4) | ((i & 192) >> 7)];
            if (i & 8) {
                memory[((registers[0] & 32768) ? (((registers[2] >> 12) & 7) << 15) : (((registers[2] >> 8) & 7) << 15)) | (registers[0] & 32767)] = x;
            }
            if (i & 1) {
                if (md === 0) {
                    if (i & 32) {
                        registers[4] = x;
                    }
                    if (i & 16) {
                        registers[5] = x;
                    }
                    if (i & 4) {
                        registers[6] = x;
                    }
                    if (i & 2) {
                        registers[7] = x;
                    }
                }
            } else {
                if (i & 32) {
                    registers[0] = x;
                }
                if (i & 16) {
                    registers[1] = x;
                }
                if ((i & 4) && md === 0) {
                    registers[2] = x;
                }
                if (i & 2) {
                    registers[3] = x;
                    j = false;
                }
            }
            if (i & 8192) {
                if (md === 0) {
                    md = 1;
                    tt = 256;
                    let Ab = registers[0];
                    let Db = registers[1];
                    let Mb = registers[2];
                    let PCb = registers[3];
                    registers[0] = registers[4];
                    registers[1] = registers[5];
                    registers[2] = registers[6];
                    registers[3] = registers[7];
                    registers[4] = Ab;
                    registers[5] = Db;
                    registers[6] = Mb;
                    registers[7] = PCb;
                } else {
                    md = 0;
                    let Ab = registers[0];
                    registers[0] = registers[4];
                    registers[4] = Ab;
                    registers[1] = 2;
                    registers[2] = 0;
                    let PCb = registers[3];
                    registers[3] = registers[7];
                    registers[7] = PCb;
                }
                j = false;
            }
        } else {
            let x = registers[1];
            let y = (i & 4096) ? registers[0] : memory[((registers[0] & 32768) ? (((registers[2] >> 12) & 7) << 15) : (((registers[2] >> 8) & 7) << 15)) | (registers[0] & 32767)];
            if (i & 64) {
                let temp = x;
                x = y;
                y = temp;
            }
            if (i & 128) {
                x = 0;
            }
            let r;
            if (i & 1024) {
                if (i & 256) {
                    y = 1;
                }
                if (i & 512) {
                    r = x - y;
                } else {
                    r = x + y;
                }
            } else {
                if (i & 512) {
                    if (i & 256) {
                        r = ~x;
                    } else {
                        r = x ^ y;
                    }
                } else {
                    if (i & 256) {
                        r = x | y;
                    } else {
                        r = x & y;
                    }
                }
            }
            if (i & 8) {
                memory[((registers[0] & 32768) ? (((registers[2] >> 12) & 7) << 15) : (((registers[2] >> 8) & 7) << 15)) | (registers[0] & 32767)] = r;
            }
            if (i & 32) {
                registers[0] = r;
            }
            if (i & 16) {
                registers[1] = r;
            }
            if (((i & 2) && r === 0) || ((i & 4) && (r & 32768)) || ((i & 1) && !(r & 32768))) {
                registers[3] = registers[0];
                updateRegisterDisplay(4);
                j = true;
            }
        }
    } else {
        registers[0] = i;
    }
    if (md === 1) {
        tt--;
        if (tt === 0) {
            md = 0;
            registers[0] = registers[4];
            registers[1] = 1;
            registers[2] = 0;
            registers[3] = registers[7];
            j = false;
        }
    }
    if (!j) {
        registers[3]++;
    }
    if (display) {
        for (let i = 0; i < 8; i++) {
            updateRegisterDisplay(i);
        }
        updateStarADisplay();
        updateModeDisplay();
    }
}

document.getElementById('tick').addEventListener('click', tick);

let runInterval = null;

let runButton = document.getElementById('run');
let stopButton = document.getElementById('stop');

let clockSpeedInput = document.getElementById('clock-speed');

function run() {
    if (runInterval !== null) {
        clearInterval(runInterval);
    }
    runInterval = setInterval(tick, 1000/clockSpeedInput.value);
    runButton.style.display = 'none';
    stopButton.style.display = 'flex';
}

function stop() {
    if (runInterval !== null) {
        clearInterval(runInterval);
        runInterval = null;
    }
    runButton.style.display = 'flex';
    stopButton.style.display = 'none';
}

runButton.addEventListener('click', run);
stopButton.addEventListener('click', stop);

clockSpeedInput.addEventListener('change', () => {
    if (runInterval !== null) {
        run();
    }
});

        </script>
    </body>
</html>