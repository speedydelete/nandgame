<!DOCTYPE html>
<html spellcheck="false">
    <head>
        <title>Nandgame Computer Emulator</title>
        <meta charset="utf-8" />
        <style>

* {
    box-sizing: border-box;
    font-family: inherit;
    background-color: inherit;
    color: inherit;
}

html, body {
    position: absolute;
    inset: 0;
}

body {
    display: flex;
    flex-direction: row;
    gap: 30px;
    margin: 0;
    padding: 30px;
    font-family: Arial, Helvetica, sans-serif;
}

body > div {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

h2 {
    padding: 15px 0;
    margin: 0;
    font-size: 1.5em;
    align-self: center;
}

#editor {
    width: 50ch;
    flex: 1;
    max-height: calc(100% - 1.5em - 50px);
    justify-self: stretch;
    background: #1e1e1e;
    color: #ffffff;
    font-family: 'Courier New', Courier, monospace !important;
    font-size: 15px !important;
    line-height: 1 !important;
    overflow-y: auto;
}

#editor::-webkit-scrollbar {
    width: 14px;
}

#editor::-webkit-scrollbar-track {
    box-shadow: inset 0 0 2px #424242;
}

#editor::-webkit-scrollbar-thumb {
    background-color: #383838;
}

@supports (scrollbar-color: #383838 #1e1e1e) {
    #editor {
        scrollbar-color: #383838 #1e1e1e;
    }
}

@supports (scrollbar-color: #383838 #1e1e1e) and selector(::-webkit-scrollbar) {
    #editor {
        scrollbar-color: initial;
    }
}

.cm-editor.cm-focused {
    outline: none;
}

.cm-editor span {
    background: inherit;
}

.cm-cursor {
    border-left-color: #ffffff !important;
}

.cm-selectionBackground, .cm-editor ::selection {
    background: #5886ff77;
}

.cm-selectionMatch {
    background-color: #474747 !important;
}

.cm-gutters, .cm-gutter {
    background: #1e1e1e !important;
    color: #858585 !important;
    border: none !important;
}

.cm-activeLine {
    background: unset !important;
}

.cm-activeLineGutter {
    background-color: inherit !important;
    color: #c6c6c6 !important;
}

button {
    padding: 8px;
    font-size: inherit;
    background-color: #0d6efd;
    color: white;
    border: none;
}

#assembled {
    width: 35ch;
    flex: 1;
    max-height: 100vh;
    padding: 5px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 15px;
    background-color: #1e1e1e;
    overflow-y: scroll;
    overflow-wrap: normal;
    white-space: pre-wrap;
}

@media (min-width: 1000px) {
    #assembled {
        width: 50ch;
    }
}

        </style>
    </head>
    <body>
        <div id="left">
            <h2>Nandgame Computer Emulator</h2>
            <div id="editor"></div>
        </div>
        <div id="middle">
            <div><button id="assemble">Assemble</button></div>
            <div id="assembled"></div>
        </div>
        <div id="right">
            
        </div>
        <script>'use strict';let currentlyLoading;function printError(e,c='red'){let x=String(e instanceof Error?e.stack:e);if(!x.includes('Error')){x=String(e)+'\n'+x.trim().split('\n').map(x=>'    at '+x).join('\n').replaceAll('@',' at ').replaceAll('at  at', 'at');}if(currentlyLoading){x=`(in ${currentlyLoading}): `+x;}if(!(document.readyState==='complete')){alert(x);return;}document.querySelectorAll('body > *').forEach(x=>x.remove());let t=document.createElement('pre');t.style.color=c;t.style.paddingLeft='15px';t.style.fontFamily='\'Courier New\',Courier,monospace';t.style.fontSize='14px';t.style.overflowX='wrap';t.textContent=x.replaceAll(/file:\/\/\/media\/fuse\/drivefs-[0-9a-f]+\/root\/code\//g,'');document.body.style.padding='0';document.body.style.paddingBottom='15px !important';document.body.appendChild(t);let l=setInterval(() => {}, 0);for(let j=1;j<=l;j++){clearInterval(j);}window.onkeydown=()=>{};}window.addEventListener('error',e=>{printError(e.error);return true;});window.addEventListener('unhandledrejection',e=>{e.preventDefault();printError(e.reason);});</script>
        <script type="module">

import {EditorView, basicSetup} from 'https://esm.sh/codemirror@6.0.1';
import {keymap} from 'https://esm.sh/@codemirror/view@^6.0.0';
import {EditorState, EditorSelection, SelectionRange} from 'https://esm.sh/@codemirror/state@^6.0.0';
import {indentWithTab} from 'https://esm.sh/@codemirror/commands@^6.0.0';
import {StreamLanguage, HighlightStyle, syntaxHighlighting, indentUnit, StringStream} from 'https://esm.sh/@codemirror/language@^6.0.0';
import {tags as t} from 'https://esm.sh/@lezer/highlight@^1.2.1';


const LABEL_REGEX = /^(\*?)[a-zA-Z_][a-zA-Z0-9_]*/;
const NUMBER_REGEX = /^-?(0b[01]+|0o[0-7]+|0x[0-9A-Fa-f]+|\d+)/;
const REGISTERS = ['A', '*A', 'D', 'M', 'PC', 'Ab', 'Db', 'Mb', 'PCb'];
const JUMPS = ['JMP', 'JEQ', 'JNE', 'JLT', 'JLE', 'JGT', 'JGE', 'SW'];
const KEYWORDS = ['label', 'define', 'macro', 'endmacro', 'DEFINE', 'MACRO', 'ENDMACRO', 'LABEL']


function highlighter(stream) {
    let match;
    if (stream.eatSpace()) {
        return;
    } else if (stream.match(/#.*/)) {
        return 'comment';
    } else if (match = stream.match(LABEL_REGEX)) {
        let name = match[0];
        if (REGISTERS.includes(name)) {
            return 'keyword';
        } else if (JUMPS.includes(name)) {
            return 'controlKeyword';
        } else if (KEYWORDS.includes(name)) {
            return 'definitionKeyword';
        } else {
            return 'variableName';
        }
    } else {
        stream.match(NUMBER_REGEX);
        stream.next();
    }
}

if (localStorage.nceCode === undefined) {
    localStorage.nceCode = 'A = 0x7FFF\n*A, D = D + 1\nA = 0\nD = ~D ; JMP';
}

let view = new EditorView({
    doc: localStorage.nceCode,
    parent: document.getElementById('editor'),
    extensions: [
        basicSetup,
        indentUnit.of('    '),
        keymap.of(indentWithTab),
        StreamLanguage.define({token: highlighter}),
        syntaxHighlighting(HighlightStyle.define([
            {tag: t.keyword, color: '#4ec9b0'},
            {tag: t.controlKeyword, color: '#d4d4a4', fontWeight: 'bold'},
            {tag: t.variableName, color: '#9cdcfe', fontWeight: 'bold'},
            {tag: t.comment, color: '#6a9955', fontStyle: 'oblique'},
            {tag: t.definitionKeyword, color: '#c586c0', fontWeight: 'bold'},
        ])),
        EditorView.updateListener.of((update) => {
            if (update.docChanged) {
                localStorage.nceCode = update.state.doc.toString();
            }
            if (update.selectionSet) {
                let selection = update.state.selection;
                selection.ranges.forEach(range => {
                    let lineEnd = update.state.doc.lineAt(range.head).to;
                    console.log(EditorSelection.create([new SelectionRange({anchor: lineEnd, head: lineEnd})]));
                    if (range.anchor > lineEnd) {
                        update.view.dispatch({selection: EditorSelection.create([new SelectionRange({anchor: lineEnd, head: lineEnd})])});
                    }
                });
            }
        }),
    ],
});


function error(msg, token) {
    for (let {line, col, file, loc, raw, length} of token.stack) {
        let src = file + ':' + line + ':' + col;
        if (loc) {
            msg += `\n    at ${loc} (${src})`;
        } else {
            msg += `\n    at ${src}`;
        }
        msg += '\n        ' + raw;
        msg += '\n        ' + ' '.repeat(col) + '^'.repeat(length) + ' (here)';
    }
    throw new SyntaxError(msg);
}

function tokenize(code) {
    let match;
    let lines = code.split('\n');
    let out = [];
    for (let lineno = 0; lineno < lines.length; lineno++) {
        let line = lines[lineno];
        let tokens = [];
        for (let i = 0; i < line.length; i++) {
            let char = line[i];
            let stack = [{
                line: lineno + 1,
                col: i,
                file: '<main>',
                raw: line,
            }];
            if (char === ' ' || char === '\t') {
                continue;
            } else if (char === '#') {
                break;
            } else if (':,;=+-&|^~'.includes(char)) {
                stack[0].length = 1;
                tokens.push({
                    type: char,
                    value: char,
                    stack,
                });
            } else if (match = line.slice(i).match(NUMBER_REGEX)) {
                stack[0].length = match[0].length;
                i += match[0].length - 1;
                tokens.push({
                    type: 'number',
                    value: parseInt(match[0]),
                    stack,
                });
            } else if (match = line.slice(i).match(LABEL_REGEX)) {
                stack[0].length = match[0].length;
                i += match[0].length - 1;
                let name = match[0];
                let type;
                if (REGISTERS.includes(name)) {
                    type = 'register';
                } else if (JUMPS.includes(name)) {
                    type = 'jump';
                } else if (KEYWORDS.includes(name)) {
                    type = 'keyword';
                    name = name.toLowerCase();
                } else {
                    type = 'variable';
                }
                tokens.push({
                    type,
                    value: name,
                    stack,
                });
            } else {
                throw new SyntaxError(`Invalid syntax on line ${lineno + 1}: '${line.slice(i)}'`);
            }
        }
        if (tokens.length > 0) {
            out.push(tokens);
        }
    }
    return out;
}

function preprocess(tokens) {
    let out = [];
    let inMacro = false;
    let macroToken;
    let macroArgs;
    let macroCode = [];
    let ids = Object.create(null);
    let lineno = 0;
    for (let i = 0; i < tokens.length; i++) {
        let line = tokens[i];
        let lines = [line];
        if (line.length === 0) {
            continue;
        } else if (line[0].type === 'keyword') {
            if (line[0].value === 'define') {
                let name = line[1];
                if (!name) {
                    error(`Expected 1 or more tokens after 'define'`, line[0]);
                } else if (name.value in ids) {
                    error(`Redeclaration of '${name.value}'`, line[0]);
                } else {
                    let data = line.slice(2);
                    for (let token of data) {
                        token.stack[0].loc = `define '${name.value}'`;
                    }
                    ids[name.value] = {
                        type: 'define',
                        value: data,
                    };
                }
            } else if (line[0].value === 'macro') {
                if (inMacro) {
                    error(`Nested macros are not allowed`, line[0]);
                }
                let name = line[1];
                if (!name) {
                    error(`Expected 1 or more tokens after 'macro'`, line[0]);
                } else if (name.value in ids) {
                    error(`Redeclaration of '${name.value}'`, line[0]);
                } else {
                    inMacro = true;
                    macroToken = line[1];
                    macroArgs = line.slice(2).map(arg => {
                        if (arg.type !== 'variable') {
                            error(`Macro arguments must be variables`, arg);
                        }
                        return arg.value;
                    });
                }
            } else if (line[0].value === 'endmacro') {
                if (!inMacro) {
                    error(`No macro to end`, line[0]);
                }
                if (line.length !== 1) {
                    error(`Expected no tokens after 'endmacro'`, line[0]);
                }
                inMacro = false;
                ids[macroToken.value] = {
                    type: 'macro',
                    value: macroCode,
                    args: macroArgs,
                };
            } else if (line[0].value === 'label') {
                if (line.length !== 2) {
                    error(`Expected 1 token after 'label'`, line[0]);
                } else if (name.type !== 'variable') {
                    error(`Expected variable after 'label'`, name);
                }
                ids[line[1].value] = {
                    type: 'label',
                    value: {
                        type: 'number',
                        value: lineno + 1,
                        stack: line[1].stack,
                    }
                };
            }
            continue;
        } else if (line[0].type === 'variable') {
            if (line.length === 2 && line[1].type === ':') {
                if (line[0].value in ids) {
                    error(`Redefinition of '${line[0].value}'`, line[0]);
                }
                line[0].stack[0].loc = 'label';
                ids[line[0].value] = {
                    type: 'label',
                    value: {
                        type: 'number',
                        value: lineno + 1,
                        stack: line[0].stack,
                    }
                };
            } else if (line[0].value in ids && ids[line[0].value].type === 'macro') {
                let value = ids[line[0].value];
                let argValues = line.slice(1);
                if (argValues.length !== value.args.length) {
                    error(`Expected ${value.args.length} arguments but got ${argValues.length} arguments`, line[0]);
                }
                let args = Object.create(null);
                for (let i = 0; i < value.args.length; i++) {
                    args[value.args[i]] = argValues[i];
                }
                let newStack = structuredClone(line[0].stack);
                lines = [];
                for (let line of value.value) {
                    let outLine = [];
                    for (let token of line) {
                        if (token.type === 'variable' && token.value in args) {
                            let arg = args[token.value];
                            arg = structuredClone(arg);
                            arg.stack.push(...structuredClone(token.stack));
                            outLine.push(arg);
                        } else {
                            token = structuredClone(token);
                            token.stack.unshift(...newStack);
                            outLine.push(token);
                        }
                    }
                    lines.push(outLine);
                }
            }
        }
        for (let line of lines) {
            let outLine = [];
            for (let token of line) {
                if (token.type === 'variable') {
                    if (!(token.value in ids)) {
                        error(`'${token.value}' is not defined`, token);
                    }
                    let {type, value} = ids[token.value];
                    if (type === 'label') {
                        value = [value];
                    }
                    if (type === 'macro') {
                        error(`Macro invocations must be at the start of a line`, token);
                    }
                    let newStack = structuredClone(token.stack);
                    outLine.push(value.map(x => {
                        x = structuredClone(x);
                        x.stack.unshift(...newStack);
                        return x;
                    }));
                } else {
                    outLine.push(token);
                }
            }
            if (outLine.length > 0) {
                if (inMacro) {
                    currentMacro.push(outLine);
                } else {
                    out.push(outLine);
                }
            }
        }
        lineno++;
    }
    if (inMacro) {
        error(`Macro '${macroToken.value}' was never ended`, macroToken);
    }
    return out;
}

const ALU_INSTRUCTIONS = {
    'D & A': 0b00000,
    'A & D': 0b00001,
    'D | A': 0b00100,
    'A | D': 0b00101,
    'D ^ A': 0b01000,
    'A ^ D': 0b01001,
    '~ D': 0b01100,
    '~ A': 0b01101,
    'D + A': 0b10000,
    'A + D': 0b10001,
    'D - A': 0b11001,
    'A - D': 0b11000,
    'D + 1': 0b10100,
    'A + 1': 0b10101,
    'D - 1': 0b11100,
    'A - 1': 0b11101,
    'D': 0b00111,
    'A': 0b00110,
    '0': 0b00010,
    '1': 0b10110,
    '-1': 0b11110,
};

function _assemble(lines) {
    let array = new Uint16Array(lines.length);
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if (line.length === 3 && line[0].type === 'register' && line[0].value === 'A' && line[1].type === '=' && line[2].type === 'number') {
            let value = line[2].value;
            if (value < 0 || value > 32767) {
                error(`The A register cannot be set to ${line[2].value}`, line[2]);
            }
            array[i] = line[2].value;
            continue;
        }
        let expression = [];
        let assignedTo = null;
        let jump = null;
        let equalsFound = false;
        let semicolonFound = false;
        let semicolonToken;
        for (let token of line) {
            if (token.type === '=') {
                if (equalsFound) {
                    error(`More than 1 equal sign in the same line`, token);
                }
                equalsFound = true;
                assignedTo = expression;
                expression = [];
            } else if (token.type === ';') {
                if (semicolonFound) {
                    error(`More than 1 equal sign in the same line`, token);
                }
                semicolonFound = true;
                semicolonToken = token;
                jump = [];
            } else if (semicolonFound) {
                jump.push(token);
            } else {
                expression.push(token);
            }
        }
        if (assignedTo === null && jump === null && expression.every(x => x.type === 'jump')) {
            jump = expression;
            expression = null;
        }
        let jumpToken;
        if (jump) {
            if (jump.length === 0) {
                error(`No jump conditions`, semicolonToken);
            } else if (jump.length !== 1) {
                error(`More than 1 jump condition`, jump[1]);
            }
            jump = jump[0];
            if (jump.type !== 'jump') {
                error(`Invalid jump condition`, jump);
            }
            jumpToken = jump;
            jump = jump.value;
        }
        let out = 1 << 15;
        if (expression && expression.length === 1 && expression[0].type === 'register' && expression[0].value !== '*A' && !(jump && jump !== 'SW')) {
            out |= 1 << 14;
            if (jump) {
                out |= 1 << 13;
            }
            let reg = expression[0].value;
            if (reg.endsWith('b')) {
                reg = reg.slice(0, -1);
                out |= 1 << 6;
            }
            if (reg.value === 'D' || reg.value === 'PC') {
                out |= 1 << 7;
            }
            if (reg.value === 'M' || reg.value === 'PC') {
                out |= 1 << 8;
            }
            if (assignedTo) {
                let regs = [];
                for (let token of assignedTo) {
                    if (token.type === 'register') {
                        if (token.value === '*A') {
                            out |= 1 << 3;
                        } else {
                            regs.push(token.value);
                        }
                    } else if (token.type === ',') {
                        continue;
                    } else {
                        error(`Expected register or comma`, token);
                    }
                }
                if (regs.some(x => x.endsWith('b'))) {
                    if (!regs.every(x => x.endsWith('b'))) {
                        error(`Cannot assign to backup and non-backup registers simultaneously`, regs[0]);
                    }
                    regs = regs.map(x => x.slice(0, -1));
                    out |= 1;
                }
                for (let reg of regs) {
                    if (reg === 'A') {
                        out |= 1 << 5;
                    } else if (reg === 'D') {
                        out |= 1 << 4;
                    } else if (reg === 'M') {
                        out |= 1 << 2;
                    } else if (reg === 'PC') {
                        out |= 1 << 1;
                    }
                }
            }
        } else if (!expression && !assignedTo && jump.type === 'SW') {
            out |= 3 << 13;
        } else {
            let key;
            if (expression && expression.length > 0) {
                let aluStr = expression.map(x => x.value).join(' ');
                key = aluStr;
                if (key.includes('*A')) {
                    key = key.replace('*A', 'A');
                }
                if (!(key in ALU_INSTRUCTIONS)) {
                    error(`Invalid ALU instruction`, expression[0]);
                }
            } else {
                key = '0';
            }
            out |= ALU_INSTRUCTIONS[key] << 6;
            if (assignedTo) {
                for (let token of assignedTo) {
                    if (token.type === 'register') {
                        if (token.value === 'A') {
                            out |= 1 << 5;
                        } else if (token.value === 'D') {
                            out |= 1 << 4;
                        } else if (token.value === '*A') {
                            out |= 1 << 3;
                        } else {
                            error(`Cannot assign to ${token.value} in ALU instruction`, token);
                        }
                    } else if (token.type === ',') {
                        continue;
                    } else {
                        error(`Expected register or comma`, token);
                    }
                }
            }
            if (jump) {
                if (jump === 'JMP' || jump === 'JNE' || jump === 'JLT' || jump === 'JLE') {
                    out |= 1 << 2;
                }
                if (jump === 'JMP' || jump === 'JEQ' || jump === 'JLE' || jump === 'JGE') {
                    out |= 1 << 1;
                }
                if (jump === 'JMP' || jump === 'JNE' || jump === 'JGT' || jump === 'JGE') {
                    out |= 1;
                }
                if (jump === 'SW') {
                    error(`Invalid jump condition for ALU instruction`, jumpToken);
                }
            }
        }
        array[i] = out;
    }
    return array;
}

let assembled = null;
let assembledElt = document.getElementById('assembled');

function assemble(code, set = false) {
    try {
        code = tokenize(code);
        code = preprocess(code);
        code = _assemble(code);
        if (set) {
            assembledElt.textContent = Array.from(code).map(x => x.toString(16).padStart(4, '0')).join(' ');
            assembledElt.style.color = 'white';
        }
        return code;
    } catch (error) {
        if (error instanceof SyntaxError) {
            assembled = null;
            if (set) {
                assembledElt.textContent = 'Error: ' + error.message;
                assembledElt.style.color = '#ff6666';
            }
        } else {
            throw error;
        }
    }
}

document.getElementById('assemble').addEventListener('click', () => {
    assemble(localStorage.nceCode, true);
});

        </script>
    </body>
</html>